<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Mikrocontrollerexperimente ohne Programmieren und Löten</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="mc-with-tasmota_files/libs/clipboard/clipboard.min.js"></script>
<script src="mc-with-tasmota_files/libs/quarto-html/quarto.js"></script>
<script src="mc-with-tasmota_files/libs/quarto-html/popper.min.js"></script>
<script src="mc-with-tasmota_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mc-with-tasmota_files/libs/quarto-html/anchor.min.js"></script>
<link href="mc-with-tasmota_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mc-with-tasmota_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mc-with-tasmota_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mc-with-tasmota_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mc-with-tasmota_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Mikrocontrollerexperimente ohne Programmieren und Löten</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="einführung" class="level1">
<h1>Einführung</h1>
<p>Für die folgenden Experimente nutzen wir ein Entwicklungsboard mit einem ESP 8266 Mikrocontroller. Auf den Fotos ist ein “NodeMCU Lua Amica”-Modul zu sehen. Alternativ kann auch ein anderes Board verwendet werden, z.B. ein “Wemos Mini D1”. Außerdem benötigen wir einen PC und eventuell ein Tablet oder Smartphone und die Zugangsdaten für ein WLAN.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="amica.jpg" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>NodeMCU Amica Mikrocontroller</figcaption>
</figure>
</div>
<p>Die Mikrocontroller-Boards mit dem ESP 8266 unterstützen WLAN und können mit Hilfe verschiedener Programmiersprachen programmiert werden. Das geht besonders einfach mit Hilfe der <a href="https://arduino.cc">Arduino-Entwicklungsumgebung</a> und in einem vereinfachten C++-Dialekt.</p>
<p>Für die folgenden Projekte machen wir es uns noch einfacher und verzichten zunächst aufs Programmieren. Stattdessen laden wir die “Tasmota”-Firmware von Theo Arends auf das Board. Die Software kan frei von https://tasmota.github.io heruntergeladen werden.</p>
<p>Die Installation gelingt am einfachsten mit dem <a href="https://tasmota.github.io/install/">Web-Installer</a>. Für die unten genannten Experimente benötigen wir die Version <strong>Tasmota Sensors</strong>.</p>
<p>Wenn die Software installiert ist, öffnet sich das Tasmota-Hauptmenü. Hier notieren wir uns zunächst die IP-Adresse (im Beispiel 192.168.178.228). Diese ist wichtig, um später auf das Modul zugzugreifen, z.B. über http://192.168.178.228 . Die Verbindung erfolgt unverschlüsselt über http und nicht https, deshalb steht im unten genannten Bild “Not secure” bzw. “Nicht sicher”.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="tasmota-menu.jpg" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Tasmota Hauptmenü</figcaption>
</figure>
</div>
</section>
<section id="ansteuern-von-licht-und-ton" class="level1">
<h1>Ansteuern von Licht und Ton</h1>
<section id="interne-led-ansteuern" class="level2">
<h2 class="anchored" data-anchor-id="interne-led-ansteuern">Interne LED ansteuern</h2>
<p>In einem ersten Experiment wollten wir die LED direkt auf dem Modul ansteuern. Hierzu verbinden wir das Modul über USB mit dem Computer oder mit einer Powerbank. Anschließend öffnen wir das Hauptmenü im Webbrowser und gehen auf “Configuration” <span class="math inline">\(\rightarrow\)</span> “Configure Module” und wählen <strong>Generic (0)</strong>. Nach “Save” und Restart” finden wir unter “Configuration” <span class="math inline">\(\rightarrow\)</span> “Configure Module” weitere Optionen.</p>
<p>Auf der linken Seite sehen wir zwei Nummerierungen, einmal D3, TX, D4 … und einmal GPIO0, GPIO1, GPIO2. Wir nutzen im folgenden immer die Nummerierung ganz links, also ohne GPIO. Diese entsprechen dem Aufdruck auf dem Mikrocontroller-Board.</p>
<p>Nun wählen wir für <strong>D4</strong> den Eintrag <strong>Relay</strong> aus. Nach einem Neustart des Moduls können wir die im Board eingebaute LED mit <strong>Toggle</strong> ein und ausschalten.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="configure-module-relais.jpg" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Konfiguration von Pin D4 als Schalter (Relay)</figcaption>
</figure>
</div>
</section>
<section id="eigene-led-ansteuern" class="level2">
<h2 class="anchored" data-anchor-id="eigene-led-ansteuern">Eigene LED ansteuern</h2>
<p>Hierfür setzen wir das Modul auf ein Steckbrett (Breadboard), so wie in der Abbildung gezeigt:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="1-led.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Ansteuerung einer LED</figcaption>
</figure>
</div>
<p>Beim Breadboard finden wir in der Mitte zwei Bereiche, bei denen die Löcher <strong>vertikal</strong> verbunden sind. Sie dienen zum Stecken und Verbinden von Bauelementen. Die Bereiche oben und unten sind die “Stromschienen”. Hier sind die Löcher <strong>horizontal</strong> miteinander verbunden.</p>
<p>Im Interesse der Einheitlichkeit legen wir das Breadboard so hin, dass die blauen Linien (-) oben verlaufen und die roten Linien (+) unten. Somit sind die von uns benötigten Pins oben und aufrecht lesbar, die USB-Stromversorung erfolgt von rechts und die Nummerierung beginnt rechts mit eins.</p>
<p>Nun verbinden wir die Bauelemente wie folgt:</p>
<ul>
<li>rote Leitung von “3V” auf die obere rote Stromschiene,</li>
<li>blaue Leitung von “GND” (Ground, Masse, Minuspol) zur blauen Stromschiene.</li>
<li>LED mit dem kürzeren Bein in die blaue Stromschiene (Masse) und dem längeren Bein (Pluspol) in einen freien Steckplatz im Mittelbereich.</li>
<li>Nun verbinden wir den Pin <strong>D4</strong> mit einer Leitung (orange) und einem Widerstand (330 Ohm) mit der LED.</li>
</ul>
<p>Mit Hilfe von <strong>Toggle</strong> können wir die LED jetzt aus- oder einschalten.</p>
<p><strong>Wichtig</strong> eine LED darf niemals direkt mit Plus und Minus verbunden werden, sondern immer über einen Widerstand, sonsonsten kann sie durchbrennen. Wie groß der Widerstand sein muss, hängt von der Stromversorgung und der LED ab.</p>
</section>
<section id="anschluss-einer-zweiten-led" class="level2">
<h2 class="anchored" data-anchor-id="anschluss-einer-zweiten-led">Anschluss einer zweiten LED</h2>
<p>Verbinde nun eine zweite (gelbe) LED mit Pin <strong>D3</strong> und konfiguriere <strong>D3</strong> als Relay Nummer 2.</p>
</section>
<section id="anschluss-eines-buzzers" class="level2">
<h2 class="anchored" data-anchor-id="anschluss-eines-buzzers">Anschluss eines Buzzers</h2>
<p>Zum Schluss verbinden wir einen aktiven Buzzer mit Pin <strong>D2</strong>. Hierbei muss der Pluspol (+, bzw. längeres Beinchen) mit dem Mikrocontroller verbunden werden und das kürzere Beinchen mit dem Minuspol. Ein Vorwiderstand ist nicht erforderlich.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2-leds+buzzer.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Zwei LEDs und ein Buzzer</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2-leds+buzzer-config.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Konfiguration mit zwei LEDs und einem Buzzer</figcaption>
</figure>
</div>
</section>
<section id="timer" class="level2">
<h2 class="anchored" data-anchor-id="timer">Timer</h2>
<p>Die Schaltung kann man auch als Wecker (Timer) nutzen. Hierzu gehen wir im Konfigurationsmenü den Punkt “Timer” und stellen eine Weckzeit ein.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="timer.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Einstellung eines Timers</figcaption>
</figure>
</div>
<p>Hierbei ist “Output” die Nummer des Relays, also z.B. 1 für die rote, 2 für die gelbe LED und 3 für den Buzzer. Mit Hilfe eines weiteren Timers kann man die LED oder den Buzzer nach einer gewissen Zeit wieder auschalten, z.B. nach 1 Minute.</p>
</section>
<section id="dimmer" class="level2">
<h2 class="anchored" data-anchor-id="dimmer">Dimmer</h2>
<p>Die LEDs lassen sich dimmen. Hierzu wählen wir anstelle von “Relay” die Einstellung “PWM” (Pulsweitenmodulation). Das bedeutet, dass die LEDs nicht mit Dauerstrom versorgt werden sondern mit kurzen Impulsen ganz schnell an- und abgeschaltet werden. Unser Auge ist nicht so schnell, deshalb erscheint uns das Licht gedimmt.</p>
<p>Im folgenden bauen wir den Buzzer und die gelbe LED wieder ab und lassen nur die rote LED übrig. Anschließend konfigurieren wir die rote LED als pulsweitenmodulierten Dimmer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="pwm.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Dimmer</figcaption>
</figure>
</div>
<p>Nach einem Neustart des Boards erscheint ein Schieberegler als Dimmer.</p>
</section>
<section id="steuern-einer-led-kette" class="level2">
<h2 class="anchored" data-anchor-id="steuern-einer-led-kette">Steuern einer LED-Kette</h2>
<p>Anstelle einer einzelnen LED kann man auch eine LED-Kette ansteuern. Wenn man die rote LED durch eine LED-Kette ersetzt bleibt sie allerdings recht dunkel. Das liegt daran, dass die LED-Kette mehr Strom benötigt als eine einzelne LED. Der 330 Ohm-Vorwiderstand begrenzt den Strom zu stark, außerdem kann der Mikrocontroller-PIN <strong>D4</strong> nicht genug Strom liefern.</p>
<p>Zur Lösung des Problems erweitern wir die Schaltung wie folgt:</p>
<ol type="1">
<li>Ersatz des 330 Ohm-Vorwiderstands durch einen kleineren Wert, z.B. 10 Ohm.</li>
<li>Trennung des Stromkreises für die LED-Kette mit einem elektronischen Schalter.</li>
</ol>
<p>Als elektronischen Schalter könnte man ein Relay verwenden. Noch einfacher, billiger und stromsparender ist ein Transistor, genau gesagt ein Feldeffekttransistor (FET). Der verwendete Typ IRLZ24N besitzt drei Anschlüsse.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="irlz24n.png" class="img-fluid figure-img" style="width:20.0%"></p>
<figcaption>Feldeffekttransistor IRLZ24N, Beschaltung: G, D, S</figcaption>
</figure>
</div>
<p>Links befindet sich das “Gate” für die Steuerleitung, in der Mitte der “Drain” an den die LED-Kette angeschlossen werden kann und rechts der “Source”-Anschluss, der mit dem Minuspol verbunden wird.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="led-chain.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Steuerung einer LED-Kette mit Feldeffekt-Transistor</figcaption>
</figure>
</div>
<p>Die Beschaltung ist wie folgt:</p>
<ul>
<li>grün: vom Mikrocontroller <strong>D4</strong> zum linken Anschluss des FET (Gate)</li>
<li>10 Ohm-Widerstand vom mitleren Anschluss des FET (Drain) zum Minuspol der LET-Kette (blau)</li>
<li>Steckbrücke (blau) vom Minuspol der Stromschiene zum rechten Anschluss des FET (Source)</li>
<li>Steckbrücke (rot) vom Pluspol der Stromschiene zur LED-Kette</li>
</ul>
<p>Wenn alles richtig angeschlossen ist, können wir die Lichterkette vom PC oder Handy aus ein und ausschalten, dimmen oder über den Timer steuern.</p>
</section>
</section>
<section id="sensoren" class="level1">
<h1>Sensoren</h1>
<p>Bei den bisherigen Beispielen ging es darum, Licht und Signale zu steuern. Mit Hilfe der Tasmota-Software ist es auch möglich Sensorsignale auszulesen.</p>
<section id="messung-von-temperatur-und-luftfeuchte" class="level2">
<h2 class="anchored" data-anchor-id="messung-von-temperatur-und-luftfeuchte">Messung von Temperatur und Luftfeuchte</h2>
<p>Für das erste Experiment benutzen wir einen digitalen Temperatur- und Feuchtesensor vom Typ AM2301, auch als DHT22 bezeichnet. Der Sensor hat 4 Anschlüsse, von denen nur drei benutzt werden:</p>
<ul>
<li>Pluspol, Signal, unbenutzt, Minuspol.</li>
</ul>
<p>Um etwas Ordnung zu bekommen, nutzen wir ab jetzt für kürzere Verbindungen keine Kabel (sogenannte Jumperkabel) mehr, sondern kurze Drahtstücke (Steckbrücken).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="am2301.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Temperatur- und Feuchtesensor AM 2301</figcaption>
</figure>
</div>
<p>In Tasmota konfigurieren wir den entsprechenden Anschluss des Boards (im vorliegenden Fall wieder <strong>D4</strong>) auf “AM2301”. Nach einem Neustart werden Temperatur, Feuchte und Taupunkt angezeigt. Falls keine Werte erscheinen, müssen wir die Verkabelung prüfen.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="am2301-display.png" class="img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Anzeige beim AM 2301</figcaption>
</figure>
</div>
<p>Der Taupunkt (dew point) ist die Temperatur, bei der der in der Luft enthaltene Wasserdampf kondensiert. Im Beispiel beträgt die relative Luftfeuchte 57.2% bei einer Lufttemperatur von 20.0°C. Wenn man die Luft abkühlt, steigt die relative Luftfeuchte, weil kalte Luft weniger Wasserdampf aufnehmen kann. Bei 11.3°C Lufttemperatur würde sie 100% betragen.</p>
</section>
<section id="temperatursensor-ds18b20" class="level2">
<h2 class="anchored" data-anchor-id="temperatursensor-ds18b20">Temperatursensor DS18B20</h2>
<p>Der DS18B20 ist ebenfalls ein Temperatursensor. Er ist sehr klein und relativ preiswert, außerdem gibt ihn auch mit Verlängerungskabel, so dass man in Flüssigkeiten messen kann.</p>
<p>Beim Anschluss an einen Mikrocontroller sind folgende Dinge zu beachten:</p>
<ol type="1">
<li>Wenn man von vorn auf die runde Seite schaut, dann ist die Anschlussreihenfolge: Pluspol, Signal, Minuspol</li>
<li>Zwischen der Signalleitung und dem Pluspol muss man einen Widerstand einfügen, einen sogenannten “Pull-Up-Widerstand”. Dieser beträgt typischerweise 4.7 Kiloohm, bei langen Verbindungskabeln auch weniger.</li>
<li>Man darf keineswegs Plus- und Minuspol vertauschen, sonst wird der Sensor heiß und ist nach wenigen Minuten kaputt!</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ds18b20.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Anschluss eines DS18B20</figcaption>
</figure>
</div>
<p>In der Tasmota-Konfiguration wählt man nun für <strong>D4</strong> die Einstellung “DS18x20” und nach einem Neustart kann man die Temperatur messen, z.B. im Tee. Hierfür kann man den verkabelten DS18B20 verwenden.</p>
</section>
<section id="luftdruck" class="level2">
<h2 class="anchored" data-anchor-id="luftdruck">Luftdruck</h2>
<p>Zur Messung des Luftdrucks kann man den Sensor BMP180 verwenden. Dieser Sensor ist sehr genau und wird z.B. in Drohnen als Höhenmesser verwendet. Eine Besonderheit ist, dass der Sensor zwei Signalleitungen benötigt. Diese heißen “I2C SDA” und “I2C SCL” und können am Mikrocontroller auch nicht beliebig platziert werden. Im vorliegenden Beispiel nutzen wir die Anschlüsse D2 und D1.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bmp180.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Luftdruck- und Temperatursensor</figcaption>
</figure>
</div>
</section>
<section id="luftdruck-und-licht" class="level2">
<h2 class="anchored" data-anchor-id="luftdruck-und-licht">Luftdruck und Licht</h2>
<p>Der Sensor aus dem vorherigen Beispiel benötigt zwei Signalleitungen statt nur einer. Das erscheint zunächst etwas umständlich aber es hat einen großen Vorteil. Die Anschlussmethode mit den zwei Signalleitungen ist ein sogenannter “Bus”, bei dem man mehrere Sensoren oder auch Displays einfach parallel nebeneinander hängen kann. So können wir zum Beispiel einen Lichtsensor BH 1750 hinzufügen, mit dem man das Licht im Zimmer oder im Freien in der Maßeinheit Lux messen kann.</p>
<p>Hierbei bleibt der erste Anschluss vom BH 1750 frei, die anderen haben die selbe Reihenfolge wie beim BMP180.</p>
<p>In der Konfiguration muss man nichts einstellen. Es genügt, das Board einmal neu zu starten und Tasmota erkennt den neuen Sensor automatisch.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2-sensors.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Temperatur, Luftdruck und Licht</figcaption>
</figure>
</div>
</section>
</section>
<section id="ausblick" class="level1">
<h1>Ausblick</h1>
<p>Mit den vorgestellten Bauteilen kann man noch mehr machen. Man kann die Schaltungen verändern und kombinieren, man kann mit Tasmota Regeln aufstellen oder man kann den Mikrocontroller ohne Tasmota direkt in C++ programmieren.</p>
<p>Mehr dazu findet man im Internet, z.B. unter:</p>
<p><a href="https://tasmota.github.io/docs">https://tasmota.github.io/docs</a></p>
<p>oder</p>
<p><a href="https://arduino.cc">https://arduino.cc</a></p>
<p>Viel Spaß!</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>